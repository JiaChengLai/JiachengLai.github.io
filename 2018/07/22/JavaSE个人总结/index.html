<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="Zh-Hans">
<head>
  <meta charset="UTF-8"/>

<script>
    (function(){
        if('123'){
            if (prompt('请输入文章密码') !== '123'){
                alert('密码错误');
                history.back();
            }
        }
    })();
</script>

<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaSE," />










<meta name="description" content="「这是一篇私密博客」">
<meta name="keywords" content="JavaSE">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE个人总结">
<meta property="og:url" content="http://yoursite.com/2018/07/22/JavaSE个人总结/index.html">
<meta property="og:site_name" content="晨">
<meta property="og:description" content="「这是一篇私密博客」">
<meta property="og:locale" content="Zh-Hans">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/71826177.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/73191166.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/44800856.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/87680775.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/79736214.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/36345927.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/51159665.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/83651399.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/65798782.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/3757032.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/17335047.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/22517987.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/58162657.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/68992385.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/69344836.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/93427990.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/31200750.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/90534695.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/51346281.jpg">
<meta property="og:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/90176986.jpg">
<meta property="og:updated_time" content="2019-02-18T07:20:45.235Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaSE个人总结">
<meta name="twitter:description" content="「这是一篇私密博客」">
<meta name="twitter:image" content="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/71826177.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/07/22/JavaSE个人总结/"/>





  <title>JavaSE个人总结 | 晨</title>
  








</head>

<!--卖萌-->
<script type="text/javascript" src="/js/src/mytitle.js"></script>

<body itemscope itemtype="http://schema.org/WebPage" lang="Zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">晨</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学无止境</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/22/JavaSE个人总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JiachengLai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="晨">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaSE个人总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-22T03:30:26+08:00">
                2018-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaSE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaSE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  「这是一篇私密博客」
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h3><p>JDK(Java Developer’s Kit)是Java开发者工具包，包含了JRE、编译器和其他工具。<br>JRE(Java Runtime Environment)是Java运行时环境，包含java虚拟机，java基础类库等。</p>
<h3 id="Java有没有goto"><a href="#Java有没有goto" class="headerlink" title="Java有没有goto?"></a>Java有没有goto?</h3><p>有goto，作为java的<strong>保留字</strong>，但不是关键字，但它基本不被使用，因为它破坏了程序按顺序执行的基本准则。</p>
<h3 id="说说-amp-和-amp-amp-的区别"><a href="#说说-amp-和-amp-amp-的区别" class="headerlink" title="说说&amp;和&amp;&amp;的区别"></a>说说&amp;和&amp;&amp;的区别</h3><ol>
<li>&amp;和&amp;&amp;都可以表示逻辑与，但&amp;&amp;具有短路功能，进行条件判断时当第一个表达式为false结果就直接为false</li>
<li>&amp;还可以作为位运算，表示按位与。</li>
</ol>
<h3 id="Object类有那些方法"><a href="#Object类有那些方法" class="headerlink" title="Object类有那些方法"></a>Object类有那些方法</h3><ul>
<li><strong>Clone()</strong> 对象克隆</li>
<li><strong>finalize()</strong> 对象的”遗言”方法 <blockquote>
<p>当gc回收一个对象的时候，主动会调用这个对象的finalize方法</p>
</blockquote>
</li>
<li><strong>toString()</strong> 返回某对象的字符串表示</li>
<li><strong>equals()</strong> 比较两对象内存地址的值</li>
<li><strong>hashCode()</strong> 得到一个对象的hashCode</li>
</ul>
<h3 id="和equals和hashCode"><a href="#和equals和hashCode" class="headerlink" title="==和equals和hashCode"></a>==和equals和hashCode</h3><p><strong>==是指对内存地址进行比较</strong><br><strong>equals()是内存地址中的值进行比较</strong><br>hashcode用于<strong>判断不可重复集合中key是否重复</strong>,当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到<strong>它应该放置的物理位置上</strong>。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。</p>
<p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/71826177.jpg" alt=""><br><strong>所以，Java对于eqauls方法和hashCode方法是这样规定的：</strong></p>
<ol>
<li>两对象相同，那hashCode值一定相同；</li>
<li>两对象hashCode相同，两对象并不一定相同（这里说的对象相同指的是用eqauls方法比较）。<br>如不按要求去做了，会发现相同的对象可以出现在Set集合中，同时，增加新元素的效率会大大下降。</li>
<li>equals()相等的对象，hashcode()一定相等；equals()不相等的对象，hashCode()不一定不相等。反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。 <h3 id="一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"><a href="#一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？" class="headerlink" title="一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"></a>一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</h3>一个“.java”文件中 可以包括多个类，但只能有一个public类，且该public类的类名必须与文件名相同</li>
</ol>
<h3 id="switch语句能否作用在byte上，能否作用在long上，能否作用在String上"><a href="#switch语句能否作用在byte上，能否作用在long上，能否作用在String上" class="headerlink" title="switch语句能否作用在byte上，能否作用在long上，能否作用在String上?"></a>switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</h3><ul>
<li>switch可作用于<code>char</code> <code>byte</code> <code>short</code> <code>int</code> <code>enum</code> <code>String</code>(jdk1.7之后才可以作用在string上)</li>
<li>switch可作用于<code>char</code> <code>byte</code> <code>short</code> <code>int</code>对应的包装类</li>
<li>switch不可作用于<code>long</code> <code>double</code> <code>float</code> <code>boolean</code>，包括他们的包装类</li>
</ul>
<h3 id="Math-round-11-5-等于多少-Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5)等于多少?Math.round(-11.5)等于多少?"></a>Math.round(11.5)等于多少?Math.round(-11.5)等于多少?</h3><p>round方法表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整<br>所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。</p>
<h3 id="final-finally-finalize的区别"><a href="#final-finally-finalize的区别" class="headerlink" title="final, finally, finalize的区别"></a>final, finally, finalize的区别</h3><ul>
<li><strong>final</strong> 用于声明类,方法和属性, 分别表示类不可继承, 方法不可复写,属性不可变 。<br>一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。</li>
<li><strong>finally</strong> 是异常处理语句结构的一部分，表示总是执行.一般用于释放资源</li>
<li><strong>finalize</strong> 是Object类的一个方法，<strong>在垃圾收集器执行的时候会调用被回收对象的此方法</strong>，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用。</li>
</ul>
<h3 id="使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"></a>使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</h3><p>引用是不可变的，引用的对象是可变的<br>即引用对象的地址值不能变，引用变量所指向的对象的内容是可以改变。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StringBuffer sbu = <span class="keyword">new</span> StringBuffer(“abc”);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对其进行重新赋值</span></span><br><span class="line">sbu = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>); <span class="comment">//会出现编译错误，被final修饰的变量是不能被重新赋值的。 </span></span><br><span class="line"></span><br><span class="line">sbu.append(<span class="string">"hello"</span>);<span class="comment">//是可以编译通过的;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="在JAVA中如何跳出当前的多重嵌套循环"><a href="#在JAVA中如何跳出当前的多重嵌套循环" class="headerlink" title="在JAVA中如何跳出当前的多重嵌套循环"></a>在JAVA中如何跳出当前的多重嵌套循环</h3><ol>
<li><p>外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break语句，即可跳出外层循环。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">done</span><br><span class="line">for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">    for(int j=0;j&lt;10;j++)&#123;</span><br><span class="line">        if(j==5)&#123;</span><br><span class="line">            break done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抛出一个异常 也能跳出</p>
</li>
<li>通过内部跳出条件控制外部循环的变量 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">    for(int j=0;j&lt;10;j++)&#123;</span><br><span class="line">        if(j==5)&#123;</span><br><span class="line">            i=10;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="给定一个txt文件，如何得到某字符串出现的次数"><a href="#给定一个txt文件，如何得到某字符串出现的次数" class="headerlink" title="给定一个txt文件，如何得到某字符串出现的次数"></a>给定一个txt文件，如何得到某字符串出现的次数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"E://test.txt"</span>);</span><br><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = is.read(b);<span class="comment">// 得到文件字符数</span></span><br><span class="line"></span><br><span class="line">String str[] = <span class="keyword">new</span> String(b,<span class="number">0</span>,a).split(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"a"</span>.equals(str[i]))count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序和快速排序的区别，以及相应的应用场景"><a href="#冒泡排序和快速排序的区别，以及相应的应用场景" class="headerlink" title="冒泡排序和快速排序的区别，以及相应的应用场景"></a>冒泡排序和快速排序的区别，以及相应的应用场景</h3><p><strong>冒泡排序</strong>是在每一次排序中，通过相邻元素的交换，将当前没有排好序的的数组的最大值移到数组的最右端，循环这个过程 数组的长度次 就可以将这个数组排好序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mp</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> swap = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; a.length; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &gt; a[i]) &#123;</span><br><span class="line">				swap = a[i];</span><br><span class="line">				a[i] = a[j];</span><br><span class="line">				a[j] = swap;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(Arrays.toString(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>快速排序</strong>使用的是分治思想，先选定一个值，将比这个值小的元素放在它的左边，比它大的元素放在它的右边，然后在左边元素中再找一个值重复上面的操作，在右边也进行相同的操作，最后整个数组就会被排序好了。</p>
<p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/73191166.jpg" alt=""></p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ef</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tag)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = a.length;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> middle = (first + end) / <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (tag == a[middle]) &#123;</span><br><span class="line">			<span class="keyword">return</span> middle;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tag &gt; a[middle]) &#123;</span><br><span class="line">			first = middle + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tag &lt; a[middle]) &#123;</span><br><span class="line">			end = middle - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相对于Statement，PreparedStatement的优点是什么？"><a href="#相对于Statement，PreparedStatement的优点是什么？" class="headerlink" title="相对于Statement，PreparedStatement的优点是什么？"></a>相对于Statement，PreparedStatement的优点是什么？</h3><ol>
<li>PreparedStatement可以防止SQL注入，因为它会自动对特殊字符进行转义</li>
<li>PreparedStatement可以使用占位符，进行动态参数化的查询<br><code>SELECT interest_rate FROM loan WHERE loan_type=?</code></li>
<li>PreparedStatement比 Statement 更快<blockquote>
<p>使用 PreparedStatement SQL语句会<strong>预编译在数据库系统中</strong>。使用预编译比普通的查询更快，因为数据库对SQL语句的分析，编译，优化已经在第一次操作前完成了。</p>
</blockquote>
</li>
<li>因为有占位符的存在,PreparedStatement不会像Statement一样有大量的字符串拼接，可读性更好</li>
</ol>
<h3 id="如何取得年月日、小时分钟秒？"><a href="#如何取得年月日、小时分钟秒？" class="headerlink" title="如何取得年月日、小时分钟秒？"></a>如何取得年月日、小时分钟秒？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">System.out.println(cal.get(Calendar.YEAR));</span><br><span class="line">System.out.println(cal.get(Calendar.MONTH)); <span class="comment">// 0 - 11</span></span><br><span class="line">System.out.println(cal.get(Calendar.DATE));</span><br><span class="line">System.out.println(cal.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">System.out.println(cal.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(cal.get(Calendar.SECOND));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line">LocalDateTime dt = LocalDateTime.now();</span><br><span class="line"> </span><br><span class="line">System.out.println(dt.getYear()); </span><br><span class="line">System.out.println(dt.getMonthValue()); <span class="comment">// 1 - 12</span></span><br><span class="line">System.out.println(dt.getDayOfMonth());</span><br><span class="line">System.out.println(dt.getHour());</span><br><span class="line">System.out.println(dt.getMinute());</span><br><span class="line">System.out.println(dt.getSecond());</span><br></pre></td></tr></table></figure>
<h3 id="如何取得从-1970-年-1-月-1-日-0-时-0-分-0-秒到现在的毫秒数？"><a href="#如何取得从-1970-年-1-月-1-日-0-时-0-分-0-秒到现在的毫秒数？" class="headerlink" title="如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？"></a>如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Calendar.getInstance().getTimeInMillis(); <span class="comment">//第一种方式</span></span><br><span class="line">System.currentTimeMillis(); <span class="comment">//第二种方式</span></span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line">Clock.systemDefaultZone().millis();</span><br></pre></td></tr></table></figure>
<h3 id="父类的静态方法能否被子类重写"><a href="#父类的静态方法能否被子类重写" class="headerlink" title="父类的静态方法能否被子类重写"></a>父类的静态方法能否被子类重写</h3><p><strong>不能</strong>。static方法，是属于这个类的，不是属于对象的。所以没有继承不继承的说法。覆盖和重写也是说的对象的方法而不是static方法。</p>
<h3 id="是否可以在static环境下访问非static变量"><a href="#是否可以在static环境下访问非static变量" class="headerlink" title="是否可以在static环境下访问非static变量"></a>是否可以在static环境下访问非static变量</h3><p>不能，因为在static环境中，调用非staitc变量，虚拟机会报错，因为非static变量还没有创建出来，没有与任何实例关联上。<br><code>static变量</code>是属于类的，在类被虚拟机被载入的时候就已经被初始化了<br><code>非static变量</code>是属于某个实例的，要等应对的实例被创建出来后才会被创建出来</p>
<h3 id="阐述静态变量和实例变量的区别？"><a href="#阐述静态变量和实例变量的区别？" class="headerlink" title="阐述静态变量和实例变量的区别？"></a>阐述静态变量和实例变量的区别？</h3><p><strong>静态变量</strong>: 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；<br><strong>实例变量</strong>: 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p>
<h3 id="什么是内部类"><a href="#什么是内部类" class="headerlink" title="什么是内部类"></a>什么是内部类</h3><p>内部类是在一个类的内部在定义一个类。</p>
<h3 id="内部类与外部类的调用"><a href="#内部类与外部类的调用" class="headerlink" title="内部类与外部类的调用"></a>内部类与外部类的调用</h3><ol>
<li>内部类可以直接调用外部类包括private的成员变量，使用外部类引用的<code>this.</code>关键字调用即可</li>
<li>但如果这个内部类是一个静态内部类 那么它不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员</li>
<li>外部类调用内部类需要建立内部类对象的实例</li>
</ol>
<hr>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h3><p><strong>面向过程</strong>就是分析出解决问题所需要的步骤，然后用函数将这些步骤一步一步实现，使用时候依次调用。<br><strong>面向对象</strong>就是将构成问题的事物分解成为一个一个的对象，建立对象的目的不是为了完成一个个的步骤，而是为了描述某个事物在解决问题步骤中的行为。</p>
<p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/44800856.jpg" alt=""></p>
<h3 id="面向对象4大特性"><a href="#面向对象4大特性" class="headerlink" title="面向对象4大特性"></a>面向对象4大特性</h3><p><strong>继承</strong>：创建新的类，并从已有类得到继承信息。提供继承信息的类叫做父类/超类，得到继承信息的类叫做子类/派生类。通过继承，子类可以继承父类的某些功能，并能根据自己的需求扩展出新的属性和行为，提高了代码的可复用性。<br><strong>封装</strong>：封装是一种可以使类中字段私有，并能通过公有方法来访问私有字段的技术。它可以隐藏一切需要隐藏的东西，并向外提供简单的编程接口。<br><strong>多态</strong>：多态是同一个行为具有多个不同表现形式或形态的能力。<strong>多态允许不同子类型的对象对同一消息作出不同的响应</strong>。简单地说就是同样的对象调用同样的方法，但却能做不同的事情。<br><strong>抽象</strong>：抽象是将一类对象的共同特征提取出来的过程。包括<strong>数据抽象</strong>和<strong>行为抽象</strong>。抽象只关心对象有哪些属性和行为，并不关心这些行为的细节是什么。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="Java的多态实现的三个必要条件"><a href="#Java的多态实现的三个必要条件" class="headerlink" title="Java的多态实现的三个必要条件"></a>Java的多态实现的三个必要条件</h4><ol>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象（向上转型）<br><code>Animal a = new Cat(); // 向上转型</code><h4 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h4>1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。<br>2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。<br>3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。<br>4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。<br>5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="Java支持多继承吗"><a href="#Java支持多继承吗" class="headerlink" title="Java支持多继承吗?"></a>Java支持多继承吗?</h4><p>不支持多继承，每个类只能继承一个类，但是可以实现多个接口</p>
<h4 id="Overload和Override的区别？Overloaded的方法是否可以改变返回值的类型"><a href="#Overload和Override的区别？Overloaded的方法是否可以改变返回值的类型" class="headerlink" title="Overload和Override的区别？Overloaded的方法是否可以改变返回值的类型?"></a>Overload和Override的区别？Overloaded的方法是否可以改变返回值的类型?</h4><ul>
<li>重写（Overide）：发生在子类和父类之间，方法名相同、参数列表相同、返回值相同。不能重写父类中为 final 的方法、重写的方法不能有比父类方法更为严格的修饰符权限、重写的方法所抛出的异常不能比父类的更大。</li>
<li>重载（Overload）：发生在同一个类之中，方法名相同、参数列表不同，与返回值无关、与final 无关、与修饰符无关、与异常无关。<h4 id="为什么函数不能根据返回类型来区分重载？"><a href="#为什么函数不能根据返回类型来区分重载？" class="headerlink" title="为什么函数不能根据返回类型来区分重载？"></a>为什么函数不能根据返回类型来区分重载？</h4>因为方法调用的时候，不能指定返回类型信息，编译器不知道我们要调用那个函数。<h4 id="父类与子类之间的调用顺序（打印结果）"><a href="#父类与子类之间的调用顺序（打印结果）" class="headerlink" title="父类与子类之间的调用顺序（打印结果）"></a>父类与子类之间的调用顺序（打印结果）</h4><strong>父类：Person.java</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Person</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的非静态代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的static代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Person()&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的无参构造函数"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	Person(String name,<span class="keyword">int</span> age)&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">		<span class="keyword">this</span>.age=age;</span><br><span class="line">		System.out.println(<span class="string">"父类的有参构造函数"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类的吃饭"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">		System.out.println(<span class="string">"父类主方法"</span>);</span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		p.eat();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>子类：Student.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> grade;</span><br><span class="line"> </span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类的非静态代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类的static代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Student()&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类的无参构造函数"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Student(String name,<span class="keyword">int</span> age)&#123;</span><br><span class="line"> </span><br><span class="line">		System.out.println(<span class="string">"子类的有参构造函数："</span>+name+<span class="string">","</span>+age);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	Student(String name,<span class="keyword">int</span> age,<span class="keyword">int</span> grade)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.grade=grade;</span><br><span class="line">		System.out.println(<span class="string">"子类的有参构造函数："</span>+name+<span class="string">","</span>+age+<span class="string">","</span>+grade);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类的吃饭"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"子类主方法"</span>);</span><br><span class="line">		System.out.println(<span class="string">"------------1-------------"</span>);</span><br><span class="line">		Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">		System.out.println(<span class="string">"------------2-------------"</span>);</span><br><span class="line">		Student s2 = <span class="keyword">new</span> Student(<span class="string">"霸王谷"</span>,<span class="number">20</span>,<span class="number">120</span>);</span><br><span class="line">		System.out.println(<span class="string">"------------3-------------"</span>);</span><br><span class="line">		Person s3 = <span class="keyword">new</span> Student();</span><br><span class="line">		System.out.println(<span class="string">"------------4-------------"</span>);</span><br><span class="line">		Student s4 = <span class="keyword">new</span> Student(<span class="string">"意识流"</span>,<span class="number">99</span>);</span><br><span class="line">		System.out.println(<span class="string">"------------5-------------"</span>);</span><br><span class="line">		Person s5 = <span class="keyword">new</span> Student(<span class="string">"我来卖萌的"</span>,<span class="number">22</span>);</span><br><span class="line">		System.out.println(<span class="string">"--------------------------"</span>);</span><br><span class="line">		s1.eat();</span><br><span class="line">		s2.eat();</span><br><span class="line">		s3.eat();</span><br><span class="line">		s4.eat();</span><br><span class="line">		s5.eat();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>执行结果</strong></p>
<p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/87680775.jpg" alt=""><br>程序运行时（一个类中），会第一时间加载运行静态代码块，一旦创建对象，就会执行非静态代码块以及无参构造方法。 而在继承中，程序运行时 会先加载父类中静态代码块 然后加载本身静态代码块，一旦创建对象（运用子类构造方法创建），就会调用 父类非静态代码块，父类构造方法，然后就是本身 非静态代码块，本身构造方法。</p>
<p><strong>java中子类继承父类程序各成员的执行顺序应该是：</strong></p>
<ol>
<li>父类静态代码块</li>
<li>子类静态代码块</li>
<li>主方法</li>
<li>父类的非静态代码块</li>
<li>父类无参构造方法</li>
<li>子类的非静态代码块</li>
<li>子类的无参构造函数（若实际子类执行的是有参构造函数，则执行有参构造函数）</li>
<li>成员函数（指定执行哪个就执行哪个成员函数，若重写了父类成员函数，则只执行子类的成员函数）。</li>
</ol>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><h4 id="接口是否可继承接口"><a href="#接口是否可继承接口" class="headerlink" title="接口是否可继承接口?"></a>接口是否可继承接口?</h4><p>可以，例如List和set继承了Collection。</p>
<h4 id="1-抽象类是否可继承具体类-concreteclass-2-抽象类是否可实现-implements-接口-3-抽象类中是否可以有静态的main方法？4-抽象类是否可以没有方法和属性？"><a href="#1-抽象类是否可继承具体类-concreteclass-2-抽象类是否可实现-implements-接口-3-抽象类中是否可以有静态的main方法？4-抽象类是否可以没有方法和属性？" class="headerlink" title="1.抽象类是否可继承具体类(concreteclass)?2.抽象类是否可实现(implements)接口?3.抽象类中是否可以有静态的main方法？4.抽象类是否可以没有方法和属性？"></a>1.抽象类是否可继承具体类(concreteclass)?2.抽象类是否可实现(implements)接口?3.抽象类中是否可以有静态的main方法？4.抽象类是否可以没有方法和属性？</h4><p>可以</p>
<h4 id="抽象类和普通类的区别"><a href="#抽象类和普通类的区别" class="headerlink" title="抽象类和普通类的区别"></a>抽象类和普通类的区别</h4><ol>
<li>普通类可以去实例化调用；<br>抽象类不能被实例化，因为它是存在于一种概念而不非具体。</li>
<li>普通类和抽象类都可以被继承，<br>抽象类被继承后子类必须重写继承的方法，除非子类也是抽象类。<h4 id="抽象类的意义"><a href="#抽象类的意义" class="headerlink" title="抽象类的意义"></a>抽象类的意义</h4></li>
<li>封装子类中重复内容（成员变量和方法）。</li>
<li>定义有抽象方法，子类虽然有不同的实现，但该方法的定义是一致的。<h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4></li>
</ol>
<ul>
<li><strong>本质区别</strong><br><strong>抽象类</strong>:抽象类是对<strong>根源</strong>的抽象 男人、女人可以设计一个更高级的抽象类——人<br><strong>接口</strong>:接口是对<strong>动作/能力</strong>的抽象 对于接口，我们可以用筷子吃饭，用叉子吃饭，那么可以把这些动作抽象成吃饭 这一个接口</li>
<li><strong>实现方式</strong><br><strong>抽象类</strong>:抽象类要被子类<strong>继承</strong>。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。<br><strong>接口</strong>:接口要被子类<strong>实现</strong>。它需要提供接口中所有声明的方法的实现</li>
<li><strong>实现/继承个数</strong><br><strong>抽象类</strong>:一个类只能继承一个抽象类（因为我们不可能同时是生物又是非生物）<br><strong>接口</strong>:一个类可以同时实现多个接口，例如跑步接口，游泳接口</li>
<li><strong>构造器</strong><br><strong>抽象类</strong>:抽象类可以有构造器<br><strong>接口</strong>:接口不能有构造器</li>
<li><strong>访问修饰符</strong><br><strong>抽象类</strong>:抽象方法可以有public、protected和default这些修饰符<br><strong>接口</strong>:接口方法默认修饰符是public。你不可以使用其它修饰符。</li>
<li><strong>main方法</strong><br><strong>抽象类</strong>:抽象方法可以有main方法并且我们可以运行它<br><strong>接口</strong>:接口没有main方法，因此我们不能运行它。</li>
<li><strong>抽象方法</strong><br><strong>抽象类</strong>:抽象类可以存在非抽象方法<br><strong>接口</strong>:接口中全是抽象方法</li>
<li><strong>静态方法</strong><br><strong>抽象类</strong>:抽象类可以有静态方法<br><strong>接口</strong>:接口中不可以有静态方法</li>
<li><strong>添加新方法</strong><br><strong>抽象类</strong>:如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。<br><strong>接口</strong>:如果你往接口中添加方法，那么你必须改变实现该接口的类。</li>
<li><strong>与正常Java类的区别</strong><br><strong>抽象类</strong>:除了你不能实例化抽象类之外，它和普通Java类没有任何区别<br><strong>接口</strong>:接口是完全不同的类型<h4 id="抽象的-abstract-方法是否可同时是静态的-static-是否可同时是本地方法-native-，是否可同时被-synchronized？"><a href="#抽象的-abstract-方法是否可同时是静态的-static-是否可同时是本地方法-native-，是否可同时被-synchronized？" class="headerlink" title="抽象的(abstract)方法是否可同时是静态的(static), 是否可同时是本地方法(native)，是否可同时被 synchronized？"></a>抽象的(abstract)方法是否可同时是静态的(static), 是否可同时是本地方法(native)，是否可同时被 synchronized？</h4>都不能。<br>抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。<br>本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。<br>Synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</li>
</ul>
<h3 id="对象的克隆-clone"><a href="#对象的克隆-clone" class="headerlink" title="对象的克隆(clone)"></a>对象的克隆(clone)</h3><h4 id="如何理解clone对象-为什么要使用克隆"><a href="#如何理解clone对象-为什么要使用克隆" class="headerlink" title="如何理解clone对象?(为什么要使用克隆?)"></a>如何理解clone对象?(为什么要使用克隆?)</h4><p>存在一个对象A，某一时刻我们可能需要一个和A完全相同的新对象B，并且要求对B对象进行操作的时候不会影响到A对象，也就是A和B是两个独立的对象。<br>Java简单的赋值语句是无法满足上述需求的，所以需要用到clone()。使用=号赋值，会将A所引用的对象在堆中地址值 拷贝给B,此时改变B就会改变A对象了。</p>
<ul>
<li>如果参数是<strong>基本类型</strong>，传递的是<strong>基本类型的字面量值的拷贝</strong>。</li>
<li>如果参数是<strong>引用类型</strong>，传递的是<strong>该参数所引用的对象在堆中地址值的拷贝</strong>。<h4 id="new和clone一个对象的过程区别"><a href="#new和clone一个对象的过程区别" class="headerlink" title="new和clone一个对象的过程区别"></a>new和clone一个对象的过程区别</h4><strong>new</strong></li>
</ul>
<ol>
<li>根据new操作符后面的类型 JVM会在堆中分配一个足够大的内存空间</li>
<li>进行对象的初始化，调用相应对象的<strong>构造函数</strong>填充对象的各个域</li>
<li>对象创建完成，将其<strong>引用地址发布到外部</strong>，外部就可以通过这个引用操纵这个对象</li>
</ol>
<p><strong>clone</strong></p>
<ol>
<li>根据要被<strong>clone</strong>的对象，分配与其相同大小的内存</li>
<li>将<strong>被clone对象中的各个域</strong> 填充 新对象的域中<font color="red">（与new不同）</font></li>
<li>clone方法完成后，一个新的相同的对象被创建，同样将其<strong>引用地址发布到外部</strong>，外部就可以通过这个引用操纵这个对象。<h4 id="clone中简单拷贝、浅拷贝与深拷贝"><a href="#clone中简单拷贝、浅拷贝与深拷贝" class="headerlink" title="clone中简单拷贝、浅拷贝与深拷贝"></a>clone中简单拷贝、浅拷贝与深拷贝</h4><strong>简单用法</strong><br>只需要在需要clone的对象上实现（implements）<strong>Cloneable接口</strong>，然后再在类中加上<strong>clone方法</strong>，在方法中只需要调用<strong>super.clone()</strong>，根据自己的需要实现即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Student <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (Student)<span class="keyword">super</span>.clone();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">		stu.setAge(<span class="number">1</span>);</span><br><span class="line">		stu.setName(<span class="string">"aa"</span>);</span><br><span class="line">		System.out.println(stu + <span class="string">" age: "</span> + stu.getAge() + <span class="string">" name: "</span> + stu.getName());</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Student sC = stu.clone();</span><br><span class="line">			System.out.println(sC + <span class="string">" sC.age: "</span> + sC.getAge() + <span class="string">" sC.name: "</span> + sC.getName());</span><br><span class="line">			sC.setAge(<span class="number">12</span>);</span><br><span class="line">			sC.setName(<span class="string">"bb"</span>);</span><br><span class="line">			System.out.println(stu + <span class="string">" age: "</span> + stu.getAge() + <span class="string">" name: "</span> + stu.getName());</span><br><span class="line">			System.out.println(sC + <span class="string">" sC.age: "</span> + sC.getAge() + <span class="string">" sC.name: "</span> + sC.getName());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testClone.Student@15db9742 age: 1 name: aa</span><br><span class="line">testClone.Student@6d06d69c sC.age: 1 sC.name: aa</span><br><span class="line">testClone.Student@15db9742 age: 1 name: aa</span><br><span class="line">testClone.Student@6d06d69c sC.age: 12 sC.name: bb</span><br></pre></td></tr></table></figure></p>
<p><strong>浅拷贝</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bag</span></span>&#123;<span class="comment">//学生的书包</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line">	<span class="keyword">private</span> String logo;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> width;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.width = width;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLogo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> logo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLogo</span><span class="params">(String logo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.logo = logo;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student2</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> Bag bag;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Bag <span class="title">getBag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bag;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBag</span><span class="params">(Bag bag)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.bag = bag;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Student2 <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (Student2)<span class="keyword">super</span>.clone();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Student2 stu = <span class="keyword">new</span> Student2();</span><br><span class="line">		stu.setAge(<span class="number">1</span>);</span><br><span class="line">		stu.setName(<span class="string">"aa"</span>);</span><br><span class="line">		Bag b = <span class="keyword">new</span> Bag();</span><br><span class="line">		b.setWidth(<span class="number">10</span>);</span><br><span class="line">		b.setLogo(<span class="string">"Nike"</span>);</span><br><span class="line">		stu.setBag(b);</span><br><span class="line">		printStudent(stu);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Student2 sC = stu.clone();</span><br><span class="line">			printStudent(sC);</span><br><span class="line">			sC.setAge(<span class="number">12</span>);</span><br><span class="line">			sC.setName(<span class="string">"bb"</span>);</span><br><span class="line">			sC.getBag().setWidth(<span class="number">100</span>);<span class="comment">//改变书包的属性</span></span><br><span class="line">			sC.getBag().setLogo(<span class="string">"JNike"</span>);</span><br><span class="line">			printStudent(stu);</span><br><span class="line">			printStudent(sC);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 输出</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> stu</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(Student2 stu)</span> </span>&#123;</span><br><span class="line">		System.out.println(stu + <span class="string">" age: "</span> + stu.getAge() + <span class="string">" name: "</span> + stu.getName() + </span><br><span class="line">				<span class="string">" bag: "</span> + stu.getBag() + <span class="string">"("</span> + stu.getBag().getLogo() + <span class="string">" width: "</span> + </span><br><span class="line">				stu.getBag().getWidth() + <span class="string">")"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testClone.Student2@15db9742 age: 1 name: aa bag: testClone.Bag@6d06d69c(Nike width: 10)</span><br><span class="line">testClone.Student2@7852e922 age: 1 name: aa bag: testClone.Bag@6d06d69c(Nike width: 10)</span><br><span class="line">testClone.Student2@15db9742 age: 1 name: aa bag: testClone.Bag@6d06d69c(JNike width: 100)</span><br><span class="line">testClone.Student2@7852e922 age: 12 name: bb bag: testClone.Bag@6d06d69c(JNike width: 100)</span><br></pre></td></tr></table></figure></p>
<p><strong>分析</strong>：发现是不是跟预期的不太一样，通过第二个同学改变书包，但是第一个同学的书包也被改变了。并且通过内存地址可知，他们是同一对象（书包）。原因：调用Object类中clone()方法产生的效果是：先在内存中开辟一块和原始对象一样的空间，然后原样拷贝原始对象中的内 容。对基本数据类型，这样的操作是没有问题的，但对非基本类型变量，我们知道它们保存的仅仅是对象的引用，这也导致clone后的非基本类型变量和原始对 象中相应的变量指向的是同一个对象。 这就是所谓的“影子”克隆。</p>
<p><strong>深拷贝</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bag</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;<span class="comment">//学生的书包</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> width;<span class="comment">//宽</span></span><br><span class="line">	<span class="keyword">private</span> String logo;<span class="comment">//品牌</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> width;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.width = width;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLogo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> logo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLogo</span><span class="params">(String logo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.logo = logo;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Bag <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (Bag)<span class="keyword">super</span>.clone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student3</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> Bag bag;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Bag <span class="title">getBag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bag;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBag</span><span class="params">(Bag bag)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.bag = bag;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Student3 <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		Student3 stu = (Student3)<span class="keyword">super</span>.clone();</span><br><span class="line">		stu.bag = bag.clone();</span><br><span class="line">		<span class="keyword">return</span> stu;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Student3 stu = <span class="keyword">new</span> Student3();</span><br><span class="line">		stu.setAge(<span class="number">1</span>);</span><br><span class="line">		stu.setName(<span class="string">"aa"</span>);</span><br><span class="line">		Bag b = <span class="keyword">new</span> Bag();</span><br><span class="line">		b.setWidth(<span class="number">10</span>);</span><br><span class="line">		b.setLogo(<span class="string">"Nike"</span>);</span><br><span class="line">		stu.setBag(b);</span><br><span class="line">		printStudent(stu);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Student3 sC = stu.clone();</span><br><span class="line">			printStudent(sC);</span><br><span class="line">			sC.setAge(<span class="number">12</span>);</span><br><span class="line">			sC.setName(<span class="string">"bb"</span>);</span><br><span class="line">			sC.getBag().setWidth(<span class="number">100</span>);<span class="comment">//改变书包的属性</span></span><br><span class="line">			sC.getBag().setLogo(<span class="string">"JNike"</span>);</span><br><span class="line">			printStudent(stu);</span><br><span class="line">			printStudent(sC);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 输出</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> stu</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(Student3 stu)</span> </span>&#123;</span><br><span class="line">		System.out.println(stu + <span class="string">" age: "</span> + stu.getAge() + <span class="string">" name: "</span> + stu.getName() + </span><br><span class="line">				<span class="string">" bag: "</span> + stu.getBag() + <span class="string">"("</span> + stu.getBag().getLogo() + <span class="string">" width: "</span> + </span><br><span class="line">				stu.getBag().getWidth() + <span class="string">")"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testClone.Student3@15db9742 age: 1 name: aa bag: testClone.Bag@6d06d69c(Nike width: 10)</span><br><span class="line">testClone.Student3@7852e922 age: 1 name: aa bag: testClone.Bag@4e25154f(Nike width: 10)</span><br><span class="line">testClone.Student3@15db9742 age: 1 name: aa bag: testClone.Bag@6d06d69c(Nike width: 10)</span><br><span class="line">testClone.Student3@7852e922 age: 12 name: bb bag: testClone.Bag@4e25154f(JNike width: 100)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Java支持的数据类型"><a href="#Java支持的数据类型" class="headerlink" title="Java支持的数据类型"></a>Java支持的数据类型</h3><ul>
<li>byte short int long</li>
<li>float double</li>
<li>boolean </li>
<li>char</li>
</ul>
<h3 id="Java8种基本类型所占字节数"><a href="#Java8种基本类型所占字节数" class="headerlink" title="Java8种基本类型所占字节数"></a>Java8种基本类型所占字节数</h3><p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/79736214.jpg" alt=""></p>
<h3 id="char型变量中能不能存储一个中文汉字，为什么？"><a href="#char型变量中能不能存储一个中文汉字，为什么？" class="headerlink" title="char型变量中能不能存储一个中文汉字，为什么？"></a>char型变量中能不能存储一个中文汉字，为什么？</h3><p>char型变量是用于储存Unicode编码的，而Unicode编码中包含汉字，所以char中能存储汉字。<br>如果某个特殊汉字没有包含在Unicode编码中，那么char则不能储存这个中文汉字。</p>
<h3 id="最有效率的方法算出2乘以8等于几"><a href="#最有效率的方法算出2乘以8等于几" class="headerlink" title="最有效率的方法算出2乘以8等于几?"></a>最有效率的方法算出2乘以8等于几?</h3><p>2 &lt;&lt; 3， 用左移运算符 将2左移3位<br>解释：因为将一个数左移n位，就相当于乘以了2的n次方，而位运算cpu直接支持的，效率最高，所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3。</p>
<h3 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h3><ul>
<li>包装类型必须实例化后才能使用，基本类型不用。</li>
<li>包装类型的初始值为null，而基本类型不是。</li>
<li>包装类型实例储存在堆中，基本类型变量储存在栈中。</li>
<li>包装类型能在集合中使用，基本类型不能。因为集合是装对象的。</li>
</ul>
<h3 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h3><p>自动装箱指的是 Java编译器自动将 <strong>基本类型</strong> 转换成 <strong>包装类型</strong><br>如将<br>int转为Integer<br>double转为Double</p>
<p><font color="red">自动拆装箱情景:</font></p>
<ul>
<li>赋值时<br>Integer a = 100;<br>JVM自动将int基本类型转化为Integer包装类型</li>
<li>方法调用时<br>add(Integer a,Integer b);<br>add(1,2)<br>JVM自动将int基本类型转化为Integer包装类型</li>
</ul>
<h3 id="包装类型试题"><a href="#包装类型试题" class="headerlink" title="包装类型试题"></a>包装类型试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Integer a1 = <span class="number">100</span>;</span><br><span class="line">Integer a2 = <span class="number">100</span>;</span><br><span class="line">System.out.println(<span class="string">"a1==a2:"</span> + (a1 == a2));</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Integer b1 = <span class="number">200</span>;</span><br><span class="line">Integer b2 = <span class="number">200</span>;</span><br><span class="line">System.out.println(<span class="string">"b1==b2:"</span> + (b1 == b2));</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer c1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer c2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">"c1==c2:"</span> + (c1 == c2));</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d1 = <span class="number">100</span>;</span><br><span class="line">Integer d2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">"d1==d2:"</span> + (d1 == d2));</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在封包的过程中其实就是调用了<code>Integer.valueOf()</code>方法把int基本类型转换成了Integer对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//IntegerCache.low=-128,IntegerCache.high=127</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在valueOf方法中对i进行了判断，如果在[-128,127]之间会从缓存中取出相应的Integer对象，而不是重新new一个Integer对象，所以当我们比较100的时候是返回的true，而200则是返回的是false。</p>
<h3 id="String能被继承吗"><a href="#String能被继承吗" class="headerlink" title="String能被继承吗"></a>String能被继承吗</h3><p>String类是final的，final表示最终的，用在类修饰符上表示此类不能被其他类扩展，所以String不能被继承</p>
<h3 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h3><p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/36345927.jpg" alt=""></p>
<h3 id="String-s-”Hello”-s-s-“world！”-这两行代码执行后，原始的String对象中的内容到底变了没有？"><a href="#String-s-”Hello”-s-s-“world！”-这两行代码执行后，原始的String对象中的内容到底变了没有？" class="headerlink" title="String s=”Hello”; s=s+“world！”;这两行代码执行后，原始的String对象中的内容到底变了没有？"></a>String s=”Hello”; s=s+“world！”;这两行代码执行后，原始的String对象中的内容到底变了没有？</h3><p>没有。因为String是不可变类（immutable class），不可变类 ，顾名思义就是说类的实例是不可被修改的。String实例的信息是在创建的时候提供，并且在整个生命周期中都不可改变。<br>在这段代码中，s原来指向一个String对象，内容是“hello”，然后我们对s进行了+操作,这时，s不指向原来那个对象了，而指向了另一个String对象，内容为”helloworld！”,原来那个对象还存在于堆内存中，只是s这个引用变量不再指向他了。</p>
<h3 id="1-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”-2-什么情况下用“-”运算符进行字符串连接比调用-StringBuffer-StringBuilder对象的-append-方法连接字符串性能更好？"><a href="#1-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”-2-什么情况下用“-”运算符进行字符串连接比调用-StringBuffer-StringBuilder对象的-append-方法连接字符串性能更好？" class="headerlink" title="1.下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;2.什么情况下用“+”运算符进行字符串连接比调用 StringBuffer/StringBuilder对象的 append 方法连接字符串性能更好？"></a>1.下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;2.什么情况下用“+”运算符进行字符串连接比调用 StringBuffer/StringBuilder对象的 append 方法连接字符串性能更好？</h3><p>编译器编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将它编译成一个这些常量相连的结果。</p>
<h3 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h3><ol>
<li><strong>对象本身是否可变</strong><br><strong>String</strong>是字符串常量。是不可变类，每次对String进行改变都相当于生成了一个新的String对象，然后将指针指向新的对象<br><strong>StringBuffer和StringBuilder</strong>是字符串变量。StringBuffer和StringBuilder表示的字符串对象可以直接进行修改，每次改变都是对StringBuffer和StringBuilder对象本身进行操作，而不是新生成对象再改变对象引用，主要方法：append（），insert（）等。</li>
<li><strong>线程是否安全</strong><br><strong>String：</strong>对象定义后不可变，线程安全。<br><strong>StringBuffer：</strong>是线程安全的（对调用方法加入同步锁），执行效率较慢，适用于多线程下操作字符串缓冲区大量数据。<br><strong>StringBuilder：</strong>是线程不安全的，适用于单线程下操作字符串缓冲区大量数据。也因为它是线程不安全的，这意味着它的所有方法都没有被Synchronized修饰，因此它的运行效率理论上也会比StringBuffer高。</li>
<li><strong>共同点</strong><br><strong>StringBuilder 与 StringBuffer</strong>有公共父类 AbstractStringBuilder(抽象类)。</li>
</ol>
<hr>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合继承关系图"><a href="#集合继承关系图" class="headerlink" title="集合继承关系图"></a>集合继承关系图</h3><p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/51159665.jpg" alt=""></p>
<h3 id="数组与链表的优缺点和区别"><a href="#数组与链表的优缺点和区别" class="headerlink" title="数组与链表的优缺点和区别"></a>数组与链表的优缺点和区别</h3><p><strong>数组</strong></p>
<blockquote>
<p>是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。</p>
</blockquote>
<p><strong>链表</strong></p>
<blockquote>
<p>元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表。</p>
</blockquote>
<p><strong>链表每个结点包括两个部分：</strong><br>一个是<strong>存储数据元素</strong>的 数据域<br>一个是<strong>存储下一个结点地址</strong>的 指针</p>
<p><strong>数组和链表的区别</strong></p>
<ol>
<li><strong>从内存存储区别</strong><br>数组从<strong>栈</strong>中分配空间, 对于程序员方便快速,但自由度小。<br>链表从<strong>堆</strong>中分配空间, 自由度大但申请管理比较麻烦。</li>
<li><strong>逻辑结构区别</strong><br><strong>数组</strong>必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费。　<br><strong>链表</strong>动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项）　</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><strong>存取方式</strong><br><strong>数组</strong>可以顺序存取或者随机存取<br><strong>链表</strong>只能顺序存取　</li>
<li><strong>存储位置</strong><br><strong>数组</strong>元素在栈区<br><strong>链表</strong>元素在堆区。</li>
<li><strong>数据存储位置</strong><br><strong>数组</strong>逻辑上相邻的元素在物理存储位置上也相邻<br><strong>链表</strong>不一定</li>
<li><strong>存储空间</strong><br><strong>链表</strong>由于带有指针域 存储密度不如数组大；　</li>
<li><p><strong>数据查找</strong><br><strong>数组</strong>是是在内存中连续存放的，所以查询快，访问数组中的元素可以按下标索引来访问，速度比较快。<br><strong>链表</strong>在内存中是不连续分布的，所以查询慢,如果要访问链表中的某个元素的话，那就得从链表的头逐个遍历，直到找到所需要的元素为止，所以链表的随机访问的效率就比数组要低 。</p>
</li>
<li><p><strong>插入和删除</strong><br><strong>数组</strong>移动后面的元素元素<br><strong>链表</strong>只需修改指针即可；　</p>
</li>
<li><strong>空间分配</strong><br><strong>数组</strong>在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败；<br><strong>链表</strong>存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；</li>
</ul>
<h3 id="ArrayList和LinkList和Vector的区别"><a href="#ArrayList和LinkList和Vector的区别" class="headerlink" title="ArrayList和LinkList和Vector的区别"></a>ArrayList和LinkList和Vector的区别</h3><ul>
<li><p>ArrayList 底层结构是数组,<strong>查询快,增删慢</strong>。<br><strong>查询快</strong> 是因为 底层是数组，在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素<br><strong>增删慢</strong> 是因为 如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。</p>
</li>
<li><p>LinkList 底层结构是双向循环链表的,<strong>查询慢,增删快</strong>。<br><strong>查询慢</strong> 是因为 它底层是双向循环链表，在内存中开辟的不是一块连续的空间，是松散的。<br><strong>增删快</strong> 是因为 它只需要将节点断开后，完成增删操作，再将节点连接起来即可。不需要移动后面所有的元素。</p>
</li>
<li><p>Vector底层结构和ArrayList一样是数组，它是线程同步的,<strong>查询快,增删慢</strong>。<br>即<strong>某一时刻只有一个线程能够写Vector</strong>，这样可以避免多线程同时写而引起的数据的不一致，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</p>
</li>
</ul>
<h3 id="List-a-new-ArrayList-和-ArrayList-a-new-ArrayList-的区别？"><a href="#List-a-new-ArrayList-和-ArrayList-a-new-ArrayList-的区别？" class="headerlink" title="List a=new ArrayList()和 ArrayList a =new ArrayList()的区别？"></a>List a=new ArrayList()和 ArrayList a =new ArrayList()的区别？</h3><ol>
<li><code>List list = new ArrayList();</code>这句创建了一个 ArrayList 的对象后把其<strong>向上转型</strong>到了 List。此时它是一个 List 对象了，<strong>有些ArrayList 有但是 List 没有的属性和方法，它就不能再用了</strong>。</li>
<li><code>ArrayList list=new ArrayList();</code>创建一对象则保留了ArrayList 的所有属性。 所以需要用到 ArrayList 独有的方法的时候不能用前者。<br>实例代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.trimToSize(); <span class="comment">//错误，没有该方法。</span></span><br><span class="line">arrayList.trimToSize();<span class="comment">//ArrayList 里有该方法。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="LinkedList数据结构"><a href="#LinkedList数据结构" class="headerlink" title="LinkedList数据结构"></a>LinkedList数据结构</h3><p>LinkedList 链表由一系列表项连接而成。一个表项总是包含 3 个部分：元素内容，前驱表和后驱表，如图所示：</p>
<p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/83651399.jpg" alt=""><br>在下图展示了一个包含 3 个元素的 LinkedList 的各个表项间的连接关系。在 JDK 的实现中，无论 LikedList 是否<br>为空，链表内部都有一个 header 表项，它既表示链表的开始，也表示链表的结尾。表项 header 的后驱表项便是链表<br>中第一个元素，表项 header 的前驱表项便是链表中最后一个元素。</p>
<p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/65798782.jpg" alt=""></p>
<h3 id="List的遍历"><a href="#List的遍历" class="headerlink" title="List的遍历"></a>List的遍历</h3><p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/3757032.jpg" alt=""></p>
<h3 id="Set的遍历"><a href="#Set的遍历" class="headerlink" title="Set的遍历"></a>Set的遍历</h3><p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/17335047.jpg" alt=""></p>
<h3 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h3><p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-1/22517987.jpg" alt=""></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>Java 中的 HashMap 是以键值对(key-value)的形式存储元素的，它使用 hashCode()和 equals()方法来向集合添加和检索元素。当调用 put()方法的时候，HashMap 会计算 key 的 hash 值，然后把键值对存储在集合中合适的索引上。如果 key 已经存在了，value 会被更新成新值。HashMap 的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。</p>
<p>当向hashmap中添加元素的时候，会自动判断当前容器的元素个数，如果<strong>当前容器元素个数</strong> &gt; <strong>当前数组长度*负载因子</strong>，则需要扩容，扩容为原来的两倍。<br>数组是无法自动扩容的，方法是用一个新的数组代替已有的小容量数组，并将数据迁移到新数组之中</p>
<h3 id="HashMap-与-HashTable-的区别"><a href="#HashMap-与-HashTable-的区别" class="headerlink" title="HashMap 与 HashTable 的区别"></a>HashMap 与 HashTable 的区别</h3><ul>
<li>是否线程同步<br><strong>HashMap</strong> 线程不同步的。<br><strong>Hashtable</strong> 线程同步的<br>在多线程并发的环境下，可以直接使用 Hashtable，但是要使用 HashMap 的话就要自己增加同步处处理 <code>Collections.synchronizeMap(hashMap);</code></li>
<li>key和value可否为null<br><strong>HashMap</strong> null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。<br><strong>Hashtable</strong>  key 和 value 都不允许出现 null 值。</li>
</ul>
<h3 id="HashMap排序"><a href="#HashMap排序" class="headerlink" title="HashMap排序"></a>HashMap排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	HashMap&lt;Integer, User&gt; users = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	users.put(<span class="number">1</span>, <span class="keyword">new</span> User(<span class="string">"张三"</span>, <span class="number">25</span>));</span><br><span class="line">	users.put(<span class="number">3</span>, <span class="keyword">new</span> User(<span class="string">"李四"</span>, <span class="number">22</span>));</span><br><span class="line">	users.put(<span class="number">2</span>, <span class="keyword">new</span> User(<span class="string">"王五"</span>, <span class="number">28</span>));</span><br><span class="line">	System.out.println(users);</span><br><span class="line">	HashMap&lt;Integer,User&gt; sortHashMap = sortHashMap(users);</span><br><span class="line">	System.out.println(sortHashMap);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 控制台输出内容</span></span><br><span class="line"><span class="comment">	* &#123;1=User [name=张三, age=25], 2=User [name=王五, age=28], 3=User [name=李四, age=22]&#125;</span></span><br><span class="line"><span class="comment">	&#123;2=User [name=王五, age=28], 1=User [name=张三, age=25], 3=User [name=李四, age=22]&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, User&gt; <span class="title">sortHashMap</span><span class="params">(HashMap&lt;Integer, User&gt; map)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 首先拿到 map 的键值对集合</span></span><br><span class="line">	Set&lt;Entry&lt;Integer, User&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 set 集合转为 List 集合，为什么，为了使用工具类的排序方法</span></span><br><span class="line">	List&lt;Entry&lt;Integer, User&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Entry&lt;Integer, User&gt;&gt;(entrySet);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用 Collections 集合工具类对 list 进行排序，排序规则使用匿名内部类来实现</span></span><br><span class="line">	Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Entry&lt;Integer, User&gt;&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;Integer, User&gt; o1, Entry&lt;Integer, User&gt; o2)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//按照要求根据 User 的 age 的倒序进行排</span></span><br><span class="line">			<span class="keyword">return</span> o2.getValue().getAge()-o1.getValue().getAge();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个新的有序的 HashMap 子类的集合</span></span><br><span class="line">	LinkedHashMap&lt;Integer, User&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;Integer, User&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将 List 中的数据存储在 LinkedHashMap 中</span></span><br><span class="line">	<span class="keyword">for</span>(Entry&lt;Integer, User&gt; entry : list)&#123;</span><br><span class="line">		linkedHashMap.put(entry.getKey(), entry.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回结果</span></span><br><span class="line">	<span class="keyword">return</span> linkedHashMap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashSet底层实现"><a href="#HashSet底层实现" class="headerlink" title="HashSet底层实现"></a>HashSet底层实现</h3><p>HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。HashSet中不允许有重复元素，这是因为HashSet是基于HashMap实现的，HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个private static final Object PRESENT = new Object();。HashSet跟HashMap一样，都是一个存放链表的数组。</p>
<p>HashSet中<code>add()</code>方法调用的是底层HashMap中的<code>put()</code>方法，而如果是在HashMap中调用put，首先会判断key是否存在，如果key存在则修改value值，如果key不存在这插入这个key-value。而在set中，因为value值没有用，也就不存在修改value值的说法，因此往HashSet中添加元素，首先判断元素（也就是key）是否存在，如果不存在这插入，如果存在着不插入，这样HashSet中就不存在重复值。</p>
<p>HashSet</p>
<ul>
<li>HashSet底层实现是hashMap</li>
<li>key 值比较 需要重写equals方法，重写hashcode方法</li>
<li>value中的值都是统一的一个private static final Object PRESENT = new Object();扩容机制和hashMap一样 16,0.75</li>
<li>add的时候调用的是hashMap的put(key,PRESENT)；方法。</li>
</ul>
<h3 id="ArrayList扩容"><a href="#ArrayList扩容" class="headerlink" title="ArrayList扩容"></a>ArrayList扩容</h3><h4 id="何时扩容"><a href="#何时扩容" class="headerlink" title="何时扩容"></a>何时扩容</h4><p>当默认开辟空间不够的时候,即 ArrayList的当前数据个数&gt;ArrayList容量时候<br>默认开辟大小为10的空间，<strong>即ArrayList初始容量为10</strong></p>
<h4 id="扩容多少"><a href="#扩容多少" class="headerlink" title="扩容多少"></a>扩容多少</h4><p><strong>原数组的长度 X 1.5 +1 ：(原长度*3)/2+1</strong></p>
<h4 id="扩容方式"><a href="#扩容方式" class="headerlink" title="扩容方式"></a>扩容方式</h4><p><code>elementData = Arrays.copyOf(elementData, newCapacity);</code></p>
<h3 id="HashMap、HashSet扩容"><a href="#HashMap、HashSet扩容" class="headerlink" title="HashMap、HashSet扩容"></a>HashMap、HashSet扩容</h3><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><ul>
<li>初始化容量：是创建hash表的容量；<strong>默认值为16</strong></li>
<li>装载/加载因子：是hash表在其容量自动增长之前，所能到达的多满的一种尺度，衡量的是hash表的空间使用程度。<strong>默认值为0.75</strong></li>
<li>衡量描述：装载因子越大，散列表装填程度越高；反之越小 </li>
</ul>
<p>实际情况：对于链表法的散列表来说</p>
<ol>
<li>装载因子越大，则空间利用率越高，但是查找效率减少，原因是在桶内链表中进行查找需要便利整个链表。</li>
<li>装载因子越小，则散列程度越高，空间利用率越低，对空间造成严重浪费。<h4 id="为什么扩容？"><a href="#为什么扩容？" class="headerlink" title="为什么扩容？"></a>为什么扩容？</h4>答 ： 保证hashMap的效率。<br>原因：随着hashMap中存储的元素越来越多，则发生碰撞的概率就会越来越大，链表的长度也会越来越长，那么就会hashMap的效率就会减低，为了保证hashMap的效率，则，就需要在存储容量达到一定值的时候进行扩容处理。<h4 id="什么时候扩容？"><a href="#什么时候扩容？" class="headerlink" title="什么时候扩容？"></a>什么时候扩容？</h4>答 ： 当达到临界值的时候进行扩容处理。<br>   临界值：容量<em>装载因子<br>   eg :　容量：16  装载因子：0.75  ===&gt;  临界值为：16 </em> 0.75 = 12<pre><code>即：当初始容量为16，装载因子为0.75的hashMap                                      存储容量到达12的时候进行扩容.
</code></pre>优化点：<br>原因：由于扩容是非常耗时的操作，为它需要重新计算元数据在新数组中的存储位置，并复制；<br>因此：如果我们预知hashMap中元素的个数，预设元素个数可以有效的提高hashMap的效率。<h4 id="怎样扩容？"><a href="#怎样扩容？" class="headerlink" title="怎样扩容？"></a>怎样扩容？</h4>答：首先计算扩容大小：存储容量<em>2 ===&gt;  16 </em> 2 = 32;<br> 申请线性表表空间，长度为 32;<br> 重新计算原来的数据在新数组中的位置，并进行复制；<h4 id="扩容多少？"><a href="#扩容多少？" class="headerlink" title="扩容多少？"></a>扩容多少？</h4>答：容量和极限值都扩大为原来的2倍<br>16 <em> 2 = 32   |  12 </em> 2 = 24 </li>
</ol>
<h3 id="如何让List、Set、Map中非线程同步的对象变成线程同步的？"><a href="#如何让List、Set、Map中非线程同步的对象变成线程同步的？" class="headerlink" title="如何让List、Set、Map中非线程同步的对象变成线程同步的？"></a>如何让List、Set、Map中非线程同步的对象变成线程同步的？</h3><p><code>Collections.synchronizeList(hashMap);</code><br><code>Collections.synchronizeSet(hashSet);</code><br><code>Collections.synchronizeMap(hashMap);</code></p>
<hr>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="java运行时异常与一般异常有何异同？"><a href="#java运行时异常与一般异常有何异同？" class="headerlink" title="java运行时异常与一般异常有何异同？"></a>java运行时异常与一般异常有何异同？</h3><p>运行时异常：由java虚拟机抛出的异常。用户不必处理。<br>一般异常是用户可以抛出的异常，如果抛出调用必须进行处理</p>
<h3 id="JAVA中的异常处理机制及异常分类"><a href="#JAVA中的异常处理机制及异常分类" class="headerlink" title="JAVA中的异常处理机制及异常分类"></a>JAVA中的异常处理机制及异常分类</h3><p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/58162657.jpg" alt=""><br>所有异常或错误的超类Throwable 下一层分为Error Exception<br>Error是java运行时系统内部错误和资源耗尽错误。<br>Exception 又分为<br>运行时异常<code>RuntimeException</code>(含NullPointException ClassCastException)<br>程序可以通过编译，只在代码运行过程时才发生，由系统自动捕获并处理<br>检查时异常<code>CheckedException</code>(含I/O错误导致的IOException SQLException)<br>必须由我们自己来处理，否则程序无法通过编译</p>
<h3 id="请写出你最常见的-5-个-RuntimeException"><a href="#请写出你最常见的-5-个-RuntimeException" class="headerlink" title="请写出你最常见的 5 个 RuntimeException"></a>请写出你最常见的 5 个 RuntimeException</h3><ul>
<li>NullPointerException 空指针异常</li>
<li>ClassNotFoundException 找不到指定的类 类的名称或路径加载错误</li>
<li>NumberFormatException 数字转换异常 字符串转换为数字时，字符串中包含非数字型字符</li>
<li>IndexOutOfBoundsException 索引越界异常</li>
<li>IllegalArgumentException 不合法参数异常</li>
<li>ClassCastException 数据类型转换异常</li>
<li>SQLException 数据库异常</li>
<li>NoSuchMethodException 方法不存在异常</li>
<li>java.lang.NoClassDefFoundException 未找到类定义错误。</li>
<li>java.lang.NoClassDefFoundException 未找到类定义错误。</li>
</ul>
<h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><p><strong>throw：</strong><br>1）throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。<br>2）throw 是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行 throw 一定是抛出了某种异常。<br><strong>throws：</strong><br>1）throws 语句是用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理。<br>2）throws 主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型。<br>3）throws 表示出现异常的一种可能性，并不一定会发生这种异常。</p>
<hr>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="流的种类"><a href="#流的种类" class="headerlink" title="流的种类"></a>流的种类</h3><p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/68992385.jpg" alt=""></p>
<h3 id="字节流转字符流"><a href="#字节流转字符流" class="headerlink" title="字节流转字符流"></a>字节流转字符流</h3><p>字节输入流转字符输入流通过 InputStreamReader 实现，该类的构造函数可以传入 InputStream 对象。<br>字节输出流转字符输出流通过 OutputStreamWriter 实现，该类的构造函数可以传入 OutputStream 对象。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="序列化的意义"><a href="#序列化的意义" class="headerlink" title="序列化的意义"></a>序列化的意义</h4><p>一种将java对象的内容进行流化使其变成字节流，达到保存对象状态，并使其能存储在文件中或在网络上传输的一种方式。</p>
<h4 id="实现序列化的方式"><a href="#实现序列化的方式" class="headerlink" title="实现序列化的方式"></a>实现序列化的方式</h4><ol>
<li>实现Serializable接口，这个接口是一个空接口，主要作用是标识这个对象是可序列化的。</li>
<li>实现Externlizable接口，Externlizable接口继承了java的序列化接口，并增加了<code>void writeExternal(ObjectOutput out) throws IOException;</code>和<code>void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;</code>两个方法</li>
</ol>
<p>在writeExternal()方法里定义了哪些属性可以序列化，哪些不可以序列化，所以，对象在经过这里就把规定能被序列化的序列化保存文件，不能序列化的不处理，然后在反序列的时候自动调</p>
<p>用readExternal()方法，根据序列顺序挨个读取进行反序列，并自动封装成对象返回，然后在测试类接收，就完成了反序列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">//增加一个新的对象</span></span><br><span class="line">      Date date=<span class="keyword">new</span> Date();</span><br><span class="line">      out.writeObject(userName);</span><br><span class="line">      out.writeObject(password);</span><br><span class="line">      out.writeObject(date);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 反序列化的扩展类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">          ClassNotFoundException </span>&#123;</span><br><span class="line">      <span class="comment">//注意这里的接受顺序是有限制的哦，否则的话会出错的</span></span><br><span class="line">      <span class="comment">// 例如上面先write的是A对象的话，那么下面先接受的也一定是A对象...</span></span><br><span class="line">      userName=(String) in.readObject();</span><br><span class="line">      password=(String) in.readObject();</span><br><span class="line">      SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">      Date date=(Date)in.readObject();       </span><br><span class="line">      System.out.println(<span class="string">"反序列化后的日期为:"</span>+sdf.format(date));</span><br><span class="line">       </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>是把对象格式化成JSON字符串传输。<br>4.采用谷歌的ProtoBuf<h4 id="序列化方式的比较"><a href="#序列化方式的比较" class="headerlink" title="序列化方式的比较"></a>序列化方式的比较</h4></li>
</ol>
<p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/69344836.jpg" alt=""></p>
<hr>
<h2 id="Java进程和线程"><a href="#Java进程和线程" class="headerlink" title="Java进程和线程"></a>Java进程和线程</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p><strong>进程</strong>是 资源（CPU、内存等）分配的基本单位，它是程序执行时的一个序列，程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪序列，进程调度器选中它时就会为它分配CPU时间，程序开始真正运行起来。<br><strong>线程</strong>是 进程的一个执行流，是CPU调度和分派的基本单位。一个进程可以由很多个线程组成。</p>
<h3 id="实现一个线程"><a href="#实现一个线程" class="headerlink" title="实现一个线程"></a>实现一个线程</h3><p>实现线程有三种方式：</p>
<ol>
<li><strong>继承 Thread 类，重写 run 方法，调用时调用Thread的 start 方法</strong><br><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/93427990.jpg" alt=""></li>
<li><strong>实现 Runable 接口，实现run 方法。再传给 Thread 构造器，调用时调用 Thread 的 start方法</strong><br><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/31200750.jpg" alt=""><br><strong>实现Runable要比继承Thread要好</strong></li>
</ol>
<ul>
<li>可以避免继承的局限性，一个类只能继承一个类，却可以实现多个接口。</li>
<li>可以实现多线程之间的资源共享</li>
</ul>
<ol start="3">
<li><strong>通过Callable和FutureTask创建线程</strong><br>a. 创建Callable接口的实现类，并实现call()方法；<br>b. 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callback对象的call()方法的返回值；<br><code>CallableThreadTest ctt = new CallableThreadTest();</code><br><code>FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(ctt);</code><br>c. 使用FutureTask对象作为Thread对象的target创建并启动新线程；<br><code>new Thread(ft,&quot;有返回值的线程&quot;).start();</code><br>d. 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。<br><code>System.out.println(&quot;子线程的返回值：&quot;+ft.get());</code></li>
</ol>
<h3 id="Java线程中run和start方法的区别"><a href="#Java线程中run和start方法的区别" class="headerlink" title="Java线程中run和start方法的区别"></a>Java线程中run和start方法的区别</h3><p>Thread.Start() 启动一个新的线程，调用该Runnable对象的run()方法。<br>Thread.Run()  在本线程内调用该Runnable对象的run()方法</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全：一个线程对一个线程安全的方法或语句进行访问时，就会被访问的方法或语句加上把锁，其他的线程就不能对被加锁的方法或语句进行操作了，必须等到这次访问结束后，锁被释放掉了，其它线程才能对这个线程安全的方法或语句进行访问。<br>指当多个线程访问一个变量时，该变量不会因为多线程访问而出现意想不到的问题，<br>为了避免多线程访问中的不可预知的问题，对于线程中多线程能访问到的变量需要加锁，也就是加Synchronized，或者对改变该变量值的方法加Synchronized限制也可以。<br> 线程安全问题都是由全局变量及静态变量引起的。<br> 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。</p>
<h3 id="Wait和Sleep和yield"><a href="#Wait和Sleep和yield" class="headerlink" title="Wait和Sleep和yield"></a>Wait和Sleep和yield</h3><p>在等待时，wait会释放锁，让别的线程可以访问它，sleep则会一直持有锁。所以wait常用于线程间的交互，sleep则用于暂停当前线程。<br>Yield用于释放线程所占有的所有CPU资源，从而让其他线程有机会运行，但是它并不能保证某个特定的线程能获得CPU资源。谁能获得CPU资源完全取决于CPU调度器，所以有时候Yield释放资源的线程可能会再次获取CPU资源。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池是指在初始化一个多线程应用程序的过程中，创建一个线程集合，然后在需要执行新的任务时重用这些线程而不是自己新建线程。</p>
<ul>
<li>可对资源进行重用，降低资源消耗</li>
<li>能对处理特定请求的最大线程数进行管理，而不是无限制的增加线程</li>
</ul>
<h3 id="如何保证数据的一致性"><a href="#如何保证数据的一致性" class="headerlink" title="如何保证数据的一致性"></a>如何保证数据的一致性</h3><p>Synchronized关键字，类锁，方法锁</p>
<h3 id="线程局部变量-ThreadLocal"><a href="#线程局部变量-ThreadLocal" class="headerlink" title="线程局部变量 ThreadLocal"></a>线程局部变量 ThreadLocal</h3><h4 id="ThreadLocal-的作用和目的"><a href="#ThreadLocal-的作用和目的" class="headerlink" title="ThreadLocal 的作用和目的"></a>ThreadLocal 的作用和目的</h4><p>用于实现线程内的数据共享，即对于相同的程序代码，多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据。</p>
<p>每个线程调用全局 ThreadLocal 对象的 set 方法，在 set 方法中，首先根据当前线程获取当前线程的ThreadLocalMap 对象，然后往这个 map 中插入一条记录，key 其实是 ThreadLocal 对象，value 是各自的set方法传进去的值。也就是每个线程其实都有一份自己独享的 ThreadLocalMap对象，该对象的 Key 是 ThreadLocal对象，值是用户设置的具体值。在线程结束时可以调用ThreadLocal.remove()方法，这样会更快释放内存，不调用也可以，因为线程结束后也可以自动释放相关的 ThreadLocal 变量。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>当一个共享变量被volatile修饰时，它会保证修改的值立即被更新到主存。通俗来说就是，线程A对一个volatile变量的修改，对于其它线程来说是可见的，即其它线程每次获取volatile变量的值都是最新的。</p>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了<strong>两层语义</strong>：</p>
<ol>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是<br>立即可见的。</li>
<li>禁止进行<strong>指令重排序</strong><br><strong>volatile</strong> 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；<br><strong>synchronized</strong> 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
</ol>
<h3 id="什么是指令重排序"><a href="#什么是指令重排序" class="headerlink" title="什么是指令重排序"></a>什么是指令重排序</h3><p>一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它<strong>不保证程序中各个语句的执行先后顺序同代码中的顺序一致</strong>，但是它会<strong>保证程序最终执行结果和代码顺序执行的结果是一致的</strong>。</p>
<p>处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<h3 id="为什么要禁止指令重排序"><a href="#为什么要禁止指令重排序" class="headerlink" title="为什么要禁止指令重排序"></a>为什么要禁止指令重排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<p>由于线程1中的语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p> 　　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<h3 id="synchronized-与-volatile-关键字的对比"><a href="#synchronized-与-volatile-关键字的对比" class="headerlink" title="synchronized 与 volatile 关键字的对比"></a>synchronized 与 volatile 关键字的对比</h3><ol>
<li><strong>volatile</strong> 仅能使用在变量级别；<br><strong>synchronized</strong> 则可以使用在变量、方法、和类级别的</li>
<li><strong>volatile</strong> 仅能实现变量的修改可见性，并不能保证原子性；<br><strong>synchronized</strong> 则可以保证变量的修改可见性和原子性</li>
<li><strong>volatile</strong> 不会造成线程的阻塞；<br><strong>synchronized</strong> 可能会造成线程的阻塞。</li>
<li><strong>volatile</strong> 标记的变量不会被编译器优化；<br><strong>synchronized</strong> 标记的变量可以被编译器优化</li>
</ol>
<h3 id="什么是线程池，如何使用？"><a href="#什么是线程池，如何使用？" class="headerlink" title="什么是线程池，如何使用？"></a>什么是线程池，如何使用？</h3><p>线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率。<br>在 JDK 的 java.util.concurrent.Executors 中提供了生成多种线程池的静态方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="number">2</span>. ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="number">3</span>. ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="number">4</span>. ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure></p>
<p>然后调用他们的 execute 方法即可。</p>
<h3 id="常用线程池？"><a href="#常用线程池？" class="headerlink" title="常用线程池？"></a>常用线程池？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</span><br><span class="line">newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。</span><br><span class="line">newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</span><br><span class="line">newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</span><br></pre></td></tr></table></figure>
<h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><ol>
<li><strong>降低资源消耗</strong>。可以重复利用已经创建的线程 来降低 线程创建和销毁造成的资源消耗。</li>
<li><strong>提高响应速度</strong>。当任务请求到达时，任务可以不需要创建新的线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<h3 id="什么是死锁，形成死锁须具备哪些条件，怎么预防死锁"><a href="#什么是死锁，形成死锁须具备哪些条件，怎么预防死锁" class="headerlink" title="什么是死锁，形成死锁须具备哪些条件，怎么预防死锁"></a>什么是死锁，形成死锁须具备哪些条件，怎么预防死锁</h3><p><strong>死锁</strong>:两个或两个以上线程竞争相同资源而造成的互相等待的状况，若无外力作用，这些进程都将无法向前推进。</p>
<p><strong>形成条件</strong>:</p>
<ul>
<li><strong>互斥条件</strong>：一个资源每次只能被一个资源所使用。</li>
<li><strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已拥有的资源保持不放。</li>
<li><strong>不可剥夺条件</strong>：进程对已获得的资源，在未使用完之前，不能强行剥夺。</li>
<li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接循环等待资源的关系。</li>
</ul>
<p><strong>死锁预防</strong><br>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p>
<ol>
<li><strong>设置线程资源请求超时时限</strong>，线程尝试获取资源时，为其设定一个请求超时时限，超过时限则放弃对该资源的请求，并释放自己所占有的资源。</li>
<li>银行家算法。</li>
<li>规定线程执行顺序，让线程按照一定顺序执行。</li>
</ol>
<h3 id="线程的互斥与同步"><a href="#线程的互斥与同步" class="headerlink" title="线程的互斥与同步"></a>线程的互斥与同步</h3><p><strong>互斥</strong><br><strong>互斥（间接相互制约）</strong>。一个系统中的多个线程必然要共享某种系统资源，如共享 CPU，共享 I/O 设备，所谓间接相互制约即源于这种资源共享，打印机就是最好的例子，线程 A 在使用打印机时，其它线程都要等待。<br><strong>同步</strong><br><strong>同步(直接相互制约)</strong>。这种制约主要是因为线程之间的合作，如有线程 A 将计算结果提供给线程 B 作进一步处理，那么线程 B 在线程 A 将数据送达之前都将处于阻塞状态。</p>
<hr>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><p>java虚拟机一是个可以执行java字节码的虚拟机进程。<br>java源文件被编译成能被java虚拟机执行的字节码文件。</p>
<h3 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h3><p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/90534695.jpg" alt=""></p>
<p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/51346281.jpg" alt=""></p>
<p>从图知，JVM主要包括4个部分:<br>1.<strong>类加载器(ClassLoader)</strong>:在JVM启动时或者在类运行时将需要的class加载到JVM中。<br>2.<strong>执行引擎</strong>:负责执行class文件中包含的字节码指令。<br>3.<strong>内存区（也叫运行时数据区）</strong>:是在JVM运行的时候操作所分配的内存区。</p>
<p>运行时内存区主要可以划分为:</p>
<ul>
<li><strong>方法区(Method Area)</strong><br>用于存储类结构信息的地方，包括常量池、静态变量、构造函数等。虽然JVM规范把方法区描述为堆的一个逻辑部分， 但它却有个别名non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。</li>
<li><strong>java堆(Heap)</strong><br>java堆(Heap)：存储java实例或者对象的地方。这块是GC的主要区域。从存储的内容我们可以很容易知道，方法区和堆是被所有java线程共享的。</li>
<li><strong>java栈(Stack)</strong><br>java栈总是和线程关联在一起，每当创建一个线程时，JVM就会为这个线程创建一个对应的java栈。在这个java栈中又会包含多个栈帧，每运行一个方法就创建一个栈帧，用于存储局部变量表、操作栈、方法返回值等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在java栈中入栈到出栈的过程。所以java栈是线程私有的。</li>
<li><strong>程序计数器(PC Register)</strong><br>用于保存当前线程执行的内存地址。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。</li>
<li><strong>本地方法栈(Native Method Stack)</strong><br>和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。</li>
</ul>
<ol start="4">
<li>本地方法接口：主要是调用C或C++实现的本地方法及返回结果</li>
</ol>
<h3 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h3><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><ol>
<li>创建一个新类时，先去内存中方法区找class文件，若没找到则去硬盘中找class文件，找到后会返回，将class文件加载到方法区</li>
<li>在class加载时，静态成员变量被分配到方法区的<strong>静态区域</strong>，非静态成员变量被分配到方法区的<strong>非静态区域</strong></li>
<li>JVM开始给静态成员变量进行初始化，赋默认值，然后根据静态成员变量书写的位置赋予其显示值，然后执行静态代码。</li>
<li>当所有的静态代码执行完成，类加载完毕</li>
</ol>
<h4 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器"></a>什么是类加载器</h4><p>加载器就是Java运行时环境（Java Runtime Environment）的一部分，负责动态加载Java类到Java虚拟机的内存空间中。</p>
<h4 id="类加载器种类"><a href="#类加载器种类" class="headerlink" title="类加载器种类"></a>类加载器种类</h4><ol>
<li><p><strong>Bootstrap ClassLoader 引导类加载器</strong><br>负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类</p>
</li>
<li><p><strong>Extension ClassLoader 扩展类加载器</strong><br>负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包</p>
</li>
<li><p><strong>App ClassLoader（SystemClassLoader）应用类加载器</strong><br>负责记载classpath中指定的jar包及目录中class</p>
</li>
<li><strong>Custom ClassLoader 用户自定义类加载器</strong><br>属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader<h4 id="双亲委任模型"><a href="#双亲委任模型" class="headerlink" title="双亲委任模型"></a>双亲委任模型</h4>如果一个类接受到类加载请求，他自己不会去加载这个请求，而是将这个类加载请求委派给父类加载器，这样一层一层传送，直到到达启动类加载器（Bootstrap ClassLoader）。<br>只有当父类加载器无法加载这个请求时，子加载器才会尝试自己去加载。<h4 id="双亲委任模型代码实现"><a href="#双亲委任模型代码实现" class="headerlink" title="双亲委任模型代码实现"></a>双亲委任模型代码实现</h4>双亲委派模型的代码实现集中在java.lang.ClassLoader的loadClass()方法当中。<br>1）首先检查类是否被加载，没有则调用父类加载器的loadClass()方法；<br>2）若父类加载器为空，则默认使用启动类加载器作为父加载器；<br>3）若父类加载失败，抛出ClassNotFoundException 异常后，再调用自己的findClass() 方法。<br>####类加载器委托机制<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//1 首先检查类是否被加载</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">//2 没有则调用父类加载器的loadClass()方法；</span></span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//3 若父类加载器为空，则默认使用启动类加载器作为父加载器；</span></span><br><span class="line">                c = findBootstrapClass0(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">           <span class="comment">//4 若父类加载失败，抛出ClassNotFoundException 异常后</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        <span class="comment">//5 再调用自己的findClass() 方法。</span></span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://hexoblog-1257009793.cos.ap-shanghai.myqcloud.com/18-8-7/90176986.jpg" alt=""></p>
<blockquote>
<p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是说当发现这个类没有的时候会先去让自己的父类去加载，父类没有再让儿子去加载，那么在这个例子中我们自己写的String应该是被Bootstrap ClassLoader加载了，所以App ClassLoader就不会再去加载我们写的String类了，导致我们写的String类是没有被加载的。</p>
</blockquote>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p><strong>能不能自己写个类叫java.lang.System？</strong><br>通常不可以，但可以采取另类方法达到这个需求。<br>解释：为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找到的类，儿子就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，自己写的System类根本没有机会得到加载。<br>但是，我们可以自己定义一个类加载器来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。</p>
<h3 id="描述一下JVM加载class文件的原理机制"><a href="#描述一下JVM加载class文件的原理机制" class="headerlink" title="描述一下JVM加载class文件的原理机制"></a>描述一下JVM加载class文件的原理机制</h3><ol>
<li>加载<br>把类的.class文件中的数据读入内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的class对象。此时的对象还不稳重，类还不可以使用。</li>
<li>连接<br>当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤</li>
<li>初始化<br>1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；<br>2)如果类中存在初始化语句，就依次执行这些初始化语句。</li>
</ol>
<h3 id="GC-是什么-为什么要有-GC"><a href="#GC-是什么-为什么要有-GC" class="headerlink" title="GC 是什么? 为什么要有 GC?"></a>GC 是什么? 为什么要有 GC?</h3><p>GC 是垃圾收集的意思（Gabge Colection），顾名思义，它是用于内存回收的。<br>内存处理是一件十分重要的事情，忘记回收内存或错误回收内存都会导致系统不稳定甚至崩溃，而Java提供的GC可以自动自动监测对象是否可回收，从而达到自动回收内存的目的。</p>
<h3 id="什么时候运行垃圾回收？"><a href="#什么时候运行垃圾回收？" class="headerlink" title="什么时候运行垃圾回收？"></a>什么时候运行垃圾回收？</h3><ul>
<li>堆内存不足的时候</li>
<li>CPU空闲的时候</li>
</ul>
<h3 id="垃圾回收的最佳做法？"><a href="#垃圾回收的最佳做法？" class="headerlink" title="垃圾回收的最佳做法？"></a>垃圾回收的最佳做法？</h3><p>用编程的方式，我们可以要求（记住这只是一个请求——不是一个命令）JVM通过调用System.gc()/Runtime.gc()方法来请求JVM进行垃圾回收。<br><code>System.gc()是Runtime.getRuntime().gc()的缩写</code><br>当内存已满，且堆上没有对象可用于垃圾回收时，JVM可能会抛出OutOfMemoryException。<br>对象在被垃圾回收从堆上删除之前，会运行finalize()方法。我们建议不要用finalize()方法写任何代码</p>
<h3 id="垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"><a href="#垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"></a>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</h3><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p>

      
    </div>
    
    
    

  <div>
    
    <div>
    
        <div style="text-align:center;color: #555;font-size:14px;">-------------The End-------------</div>
    
</div>
    
  </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaSE/" rel="tag"><i class="fa fa-tag"></i>JavaSE</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/13/Oracle(6)存储过程和函数、包和包体、触发器/" rel="next" title="Oracle(6)存储过程和函数、包和包体、触发器">
                <i class="fa fa-chevron-left"></i> Oracle(6)存储过程和函数、包和包体、触发器
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/31/删除文件夹中重复文件/" rel="prev" title="删除文件夹中重复文件">
                删除文件夹中重复文件 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="JiachengLai" />
            
              <p class="site-author-name" itemprop="name">JiachengLai</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅，绝知此事要躬行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java基础"><span class="nav-number">1.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK和JRE"><span class="nav-number">1.1.</span> <span class="nav-text">JDK和JRE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java有没有goto"><span class="nav-number">1.2.</span> <span class="nav-text">Java有没有goto?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说说-amp-和-amp-amp-的区别"><span class="nav-number">1.3.</span> <span class="nav-text">说说&amp;和&amp;&amp;的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object类有那些方法"><span class="nav-number">1.4.</span> <span class="nav-text">Object类有那些方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和equals和hashCode"><span class="nav-number">1.5.</span> <span class="nav-text">==和equals和hashCode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"><span class="nav-number">1.6.</span> <span class="nav-text">一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch语句能否作用在byte上，能否作用在long上，能否作用在String上"><span class="nav-number">1.7.</span> <span class="nav-text">switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math-round-11-5-等于多少-Math-round-11-5-等于多少"><span class="nav-number">1.8.</span> <span class="nav-text">Math.round(11.5)等于多少?Math.round(-11.5)等于多少?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-finally-finalize的区别"><span class="nav-number">1.9.</span> <span class="nav-text">final, finally, finalize的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><span class="nav-number">1.10.</span> <span class="nav-text">使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在JAVA中如何跳出当前的多重嵌套循环"><span class="nav-number">1.11.</span> <span class="nav-text">在JAVA中如何跳出当前的多重嵌套循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给定一个txt文件，如何得到某字符串出现的次数"><span class="nav-number">1.12.</span> <span class="nav-text">给定一个txt文件，如何得到某字符串出现的次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#冒泡排序和快速排序的区别，以及相应的应用场景"><span class="nav-number">1.13.</span> <span class="nav-text">冒泡排序和快速排序的区别，以及相应的应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分查找"><span class="nav-number">1.14.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相对于Statement，PreparedStatement的优点是什么？"><span class="nav-number">1.15.</span> <span class="nav-text">相对于Statement，PreparedStatement的优点是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何取得年月日、小时分钟秒？"><span class="nav-number">1.16.</span> <span class="nav-text">如何取得年月日、小时分钟秒？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何取得从-1970-年-1-月-1-日-0-时-0-分-0-秒到现在的毫秒数？"><span class="nav-number">1.17.</span> <span class="nav-text">如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#父类的静态方法能否被子类重写"><span class="nav-number">1.18.</span> <span class="nav-text">父类的静态方法能否被子类重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#是否可以在static环境下访问非static变量"><span class="nav-number">1.19.</span> <span class="nav-text">是否可以在static环境下访问非static变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阐述静态变量和实例变量的区别？"><span class="nav-number">1.20.</span> <span class="nav-text">阐述静态变量和实例变量的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是内部类"><span class="nav-number">1.21.</span> <span class="nav-text">什么是内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类与外部类的调用"><span class="nav-number">1.22.</span> <span class="nav-text">内部类与外部类的调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象"><span class="nav-number">2.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象和面向过程"><span class="nav-number">2.1.</span> <span class="nav-text">面向对象和面向过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象4大特性"><span class="nav-number">2.2.</span> <span class="nav-text">面向对象4大特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态"><span class="nav-number">2.3.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java的多态实现的三个必要条件"><span class="nav-number">2.3.1.</span> <span class="nav-text">Java的多态实现的三个必要条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态的好处"><span class="nav-number">2.3.2.</span> <span class="nav-text">多态的好处</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">2.4.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java支持多继承吗"><span class="nav-number">2.4.1.</span> <span class="nav-text">Java支持多继承吗?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Overload和Override的区别？Overloaded的方法是否可以改变返回值的类型"><span class="nav-number">2.4.2.</span> <span class="nav-text">Overload和Override的区别？Overloaded的方法是否可以改变返回值的类型?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么函数不能根据返回类型来区分重载？"><span class="nav-number">2.4.3.</span> <span class="nav-text">为什么函数不能根据返回类型来区分重载？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#父类与子类之间的调用顺序（打印结果）"><span class="nav-number">2.4.4.</span> <span class="nav-text">父类与子类之间的调用顺序（打印结果）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象"><span class="nav-number">2.5.</span> <span class="nav-text">抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口是否可继承接口"><span class="nav-number">2.5.1.</span> <span class="nav-text">接口是否可继承接口?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-抽象类是否可继承具体类-concreteclass-2-抽象类是否可实现-implements-接口-3-抽象类中是否可以有静态的main方法？4-抽象类是否可以没有方法和属性？"><span class="nav-number">2.5.2.</span> <span class="nav-text">1.抽象类是否可继承具体类(concreteclass)?2.抽象类是否可实现(implements)接口?3.抽象类中是否可以有静态的main方法？4.抽象类是否可以没有方法和属性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象类和普通类的区别"><span class="nav-number">2.5.3.</span> <span class="nav-text">抽象类和普通类的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象类的意义"><span class="nav-number">2.5.4.</span> <span class="nav-text">抽象类的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象类和接口的区别"><span class="nav-number">2.5.5.</span> <span class="nav-text">抽象类和接口的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象的-abstract-方法是否可同时是静态的-static-是否可同时是本地方法-native-，是否可同时被-synchronized？"><span class="nav-number">2.5.6.</span> <span class="nav-text">抽象的(abstract)方法是否可同时是静态的(static), 是否可同时是本地方法(native)，是否可同时被 synchronized？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的克隆-clone"><span class="nav-number">2.6.</span> <span class="nav-text">对象的克隆(clone)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何理解clone对象-为什么要使用克隆"><span class="nav-number">2.6.1.</span> <span class="nav-text">如何理解clone对象?(为什么要使用克隆?)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new和clone一个对象的过程区别"><span class="nav-number">2.6.2.</span> <span class="nav-text">new和clone一个对象的过程区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clone中简单拷贝、浅拷贝与深拷贝"><span class="nav-number">2.6.3.</span> <span class="nav-text">clone中简单拷贝、浅拷贝与深拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型"><span class="nav-number">3.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java支持的数据类型"><span class="nav-number">3.1.</span> <span class="nav-text">Java支持的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java8种基本类型所占字节数"><span class="nav-number">3.2.</span> <span class="nav-text">Java8种基本类型所占字节数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#char型变量中能不能存储一个中文汉字，为什么？"><span class="nav-number">3.3.</span> <span class="nav-text">char型变量中能不能存储一个中文汉字，为什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最有效率的方法算出2乘以8等于几"><span class="nav-number">3.4.</span> <span class="nav-text">最有效率的方法算出2乘以8等于几?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本类型和包装类型的区别"><span class="nav-number">3.5.</span> <span class="nav-text">基本类型和包装类型的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动拆装箱"><span class="nav-number">3.6.</span> <span class="nav-text">自动拆装箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包装类型试题"><span class="nav-number">3.7.</span> <span class="nav-text">包装类型试题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String能被继承吗"><span class="nav-number">3.8.</span> <span class="nav-text">String能被继承吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String类常用方法"><span class="nav-number">3.9.</span> <span class="nav-text">String类常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-s-”Hello”-s-s-“world！”-这两行代码执行后，原始的String对象中的内容到底变了没有？"><span class="nav-number">3.10.</span> <span class="nav-text">String s=”Hello”; s=s+“world！”;这两行代码执行后，原始的String对象中的内容到底变了没有？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-下面这条语句一共创建了多少个对象：String-s-”a”-”b”-”c”-”d”-2-什么情况下用“-”运算符进行字符串连接比调用-StringBuffer-StringBuilder对象的-append-方法连接字符串性能更好？"><span class="nav-number">3.11.</span> <span class="nav-text">1.下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;2.什么情况下用“+”运算符进行字符串连接比调用 StringBuffer/StringBuilder对象的 append 方法连接字符串性能更好？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String、StringBuffer、StringBuilder的区别"><span class="nav-number">3.12.</span> <span class="nav-text">String、StringBuffer、StringBuilder的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合"><span class="nav-number">4.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#集合继承关系图"><span class="nav-number">4.1.</span> <span class="nav-text">集合继承关系图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组与链表的优缺点和区别"><span class="nav-number">4.2.</span> <span class="nav-text">数组与链表的优缺点和区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList和LinkList和Vector的区别"><span class="nav-number">4.3.</span> <span class="nav-text">ArrayList和LinkList和Vector的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List-a-new-ArrayList-和-ArrayList-a-new-ArrayList-的区别？"><span class="nav-number">4.4.</span> <span class="nav-text">List a=new ArrayList()和 ArrayList a =new ArrayList()的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList数据结构"><span class="nav-number">4.5.</span> <span class="nav-text">LinkedList数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List的遍历"><span class="nav-number">4.6.</span> <span class="nav-text">List的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set的遍历"><span class="nav-number">4.7.</span> <span class="nav-text">Set的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map的遍历"><span class="nav-number">4.8.</span> <span class="nav-text">Map的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-number">4.9.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-与-HashTable-的区别"><span class="nav-number">4.10.</span> <span class="nav-text">HashMap 与 HashTable 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap排序"><span class="nav-number">4.11.</span> <span class="nav-text">HashMap排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet底层实现"><span class="nav-number">4.12.</span> <span class="nav-text">HashSet底层实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList扩容"><span class="nav-number">4.13.</span> <span class="nav-text">ArrayList扩容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#何时扩容"><span class="nav-number">4.13.1.</span> <span class="nav-text">何时扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩容多少"><span class="nav-number">4.13.2.</span> <span class="nav-text">扩容多少</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩容方式"><span class="nav-number">4.13.3.</span> <span class="nav-text">扩容方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap、HashSet扩容"><span class="nav-number">4.14.</span> <span class="nav-text">HashMap、HashSet扩容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#参数介绍"><span class="nav-number">4.14.1.</span> <span class="nav-text">参数介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么扩容？"><span class="nav-number">4.14.2.</span> <span class="nav-text">为什么扩容？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么时候扩容？"><span class="nav-number">4.14.3.</span> <span class="nav-text">什么时候扩容？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#怎样扩容？"><span class="nav-number">4.14.4.</span> <span class="nav-text">怎样扩容？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩容多少？"><span class="nav-number">4.14.5.</span> <span class="nav-text">扩容多少？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何让List、Set、Map中非线程同步的对象变成线程同步的？"><span class="nav-number">4.15.</span> <span class="nav-text">如何让List、Set、Map中非线程同步的对象变成线程同步的？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常"><span class="nav-number">5.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java运行时异常与一般异常有何异同？"><span class="nav-number">5.1.</span> <span class="nav-text">java运行时异常与一般异常有何异同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA中的异常处理机制及异常分类"><span class="nav-number">5.2.</span> <span class="nav-text">JAVA中的异常处理机制及异常分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请写出你最常见的-5-个-RuntimeException"><span class="nav-number">5.3.</span> <span class="nav-text">请写出你最常见的 5 个 RuntimeException</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throw和throws的区别"><span class="nav-number">5.4.</span> <span class="nav-text">throw和throws的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO"><span class="nav-number">6.</span> <span class="nav-text">IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流的种类"><span class="nav-number">6.1.</span> <span class="nav-text">流的种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节流转字符流"><span class="nav-number">6.2.</span> <span class="nav-text">字节流转字符流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序列化"><span class="nav-number">6.3.</span> <span class="nav-text">序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#序列化的意义"><span class="nav-number">6.3.1.</span> <span class="nav-text">序列化的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现序列化的方式"><span class="nav-number">6.3.2.</span> <span class="nav-text">实现序列化的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#序列化方式的比较"><span class="nav-number">6.3.3.</span> <span class="nav-text">序列化方式的比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java进程和线程"><span class="nav-number">7.</span> <span class="nav-text">Java进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程和线程"><span class="nav-number">7.1.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现一个线程"><span class="nav-number">7.2.</span> <span class="nav-text">实现一个线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java线程中run和start方法的区别"><span class="nav-number">7.3.</span> <span class="nav-text">Java线程中run和start方法的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全"><span class="nav-number">7.4.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Wait和Sleep和yield"><span class="nav-number">7.5.</span> <span class="nav-text">Wait和Sleep和yield</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">7.6.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何保证数据的一致性"><span class="nav-number">7.7.</span> <span class="nav-text">如何保证数据的一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程局部变量-ThreadLocal"><span class="nav-number">7.8.</span> <span class="nav-text">线程局部变量 ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal-的作用和目的"><span class="nav-number">7.8.1.</span> <span class="nav-text">ThreadLocal 的作用和目的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile"><span class="nav-number">7.9.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是指令重排序"><span class="nav-number">7.10.</span> <span class="nav-text">什么是指令重排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要禁止指令重排序"><span class="nav-number">7.11.</span> <span class="nav-text">为什么要禁止指令重排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-与-volatile-关键字的对比"><span class="nav-number">7.12.</span> <span class="nav-text">synchronized 与 volatile 关键字的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是线程池，如何使用？"><span class="nav-number">7.13.</span> <span class="nav-text">什么是线程池，如何使用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用线程池？"><span class="nav-number">7.14.</span> <span class="nav-text">常用线程池？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池的好处"><span class="nav-number">7.15.</span> <span class="nav-text">线程池的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是死锁，形成死锁须具备哪些条件，怎么预防死锁"><span class="nav-number">7.16.</span> <span class="nav-text">什么是死锁，形成死锁须具备哪些条件，怎么预防死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的互斥与同步"><span class="nav-number">7.17.</span> <span class="nav-text">线程的互斥与同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">8.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java虚拟机"><span class="nav-number">8.1.</span> <span class="nav-text">Java虚拟机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM结构"><span class="nav-number">8.2.</span> <span class="nav-text">JVM结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM类加载机制"><span class="nav-number">8.3.</span> <span class="nav-text">JVM类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类加载过程"><span class="nav-number">8.3.1.</span> <span class="nav-text">类加载过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是类加载器"><span class="nav-number">8.3.2.</span> <span class="nav-text">什么是类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类加载器种类"><span class="nav-number">8.3.3.</span> <span class="nav-text">类加载器种类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委任模型"><span class="nav-number">8.3.4.</span> <span class="nav-text">双亲委任模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委任模型代码实现"><span class="nav-number">8.3.5.</span> <span class="nav-text">双亲委任模型代码实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面试题"><span class="nav-number">8.3.6.</span> <span class="nav-text">面试题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#描述一下JVM加载class文件的原理机制"><span class="nav-number">8.4.</span> <span class="nav-text">描述一下JVM加载class文件的原理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-是什么-为什么要有-GC"><span class="nav-number">8.5.</span> <span class="nav-text">GC 是什么? 为什么要有 GC?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么时候运行垃圾回收？"><span class="nav-number">8.6.</span> <span class="nav-text">什么时候运行垃圾回收？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收的最佳做法？"><span class="nav-number">8.7.</span> <span class="nav-text">垃圾回收的最佳做法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"><span class="nav-number">8.8.</span> <span class="nav-text">垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JiachengLai</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
